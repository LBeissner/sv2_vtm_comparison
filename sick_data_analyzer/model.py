import numpy as np
import math
import re
from scipy.spatial.transform import Rotation

ANGLE_INCREMENT: np.float32 = 0.15


class PlaneModel(object):
    """
    Creates an object PlaneModel. This model simulates a plane of given size as point
    cloud generated by either safeVisionary2 or Visionary-T Mini TOF depth camera.
    TODO: At the current point in development the point cloud is distortion-free.
    """

    __plane_width: np.float32
    __plane_height: np.float32
    __steps_x: np.uint16
    __steps_y: np.uint16
    __plane_points: np.ndarray

    def __init__(
        self,
        distance: np.float32,
        specimen_width: np.float32 = 420.0,
        specimen_height=594.0,
    ):
        self.__plane_width = specimen_width
        self.__plane_height = specimen_height

        self.__calculate_size(distance=distance)
        self.__calculate_plane(distance=distance)

    @classmethod
    def from_file_name(cls, file_name: str):
        """
            Creates an Instance  of PlaneModel deriving its distance to
            the camera and its unit of measurement from the file name.

        Args:
            file_name (str): File name to extract the distance and unit of measurement from.
                             The naming convention is "cameraType_record_distanceUnit_filtered".

        Raises:
            ValueError: Raised, if an invalid unit of measurement is selected. Only metric units from mm to m are  allowed.

        Returns:
            PlaneModel: Instance of PlaneModel.
        """

        options = ["mm", "cm", "dm", "m"]

        substrings = re.split("_", file_name)
        unit = re.split("\d+", substrings[2].strip())[2]

        if unit not in options:
            raise ValueError(
                f"Invalid unit of meaurement selected! Select a metric unit from:\t{options}"
            )

        # get distance from substrings
        distance = float(
            re.sub(",", ".", re.findall(r"([-+]?\d+\,\d+)", substrings[2].strip())[0])
        )

        # always convert to mm
        exponent = options.index(unit)
        distance *= pow(10, exponent)

        return cls(distance=distance)

    def __calculate_size(self, distance: np.float32):
        """
            Calculates the number of steps in x and y direction necessary to simulate the full plane at a given distance.

        Args:
            distance (np.float32): Distance between the plane and the origin of the CCS.
        """

        # calculate the two point angles of the pyramid formed by
        # the CCS origin and the plane model at set distance
        alpha = 2 * math.atan(self.__plane_height / (2 * distance))
        beta = 2 * math.atan(self.__plane_width / (2 * distance))

        # calculate the sizes in steps of 0.14 degrees
        # if necessary, stay slightly larger than the actual test specimen
        steps_x = round(alpha / math.radians(ANGLE_INCREMENT))
        steps_y = round(beta / math.radians(ANGLE_INCREMENT))

        # only return odd sizes to keep the cardinal point at the plane centre
        if steps_x % 2 == 0:
            steps_x += 1

        if steps_y % 2 == 0:
            steps_y += 1

        self.__steps_x = steps_x
        self.__steps_y = steps_y

    def __calculate_plane(self, distance: np.float32):
        """
            Calculates the point coordinates of the plane model and stores them in the instance.
            The center of the plane is located on the optical axis.

        Args:
            distance (np.float32): Distance between the plane and the origin of the CCS.
        """

        # calculate the normalized position vector Z of the cardinal point
        cardinal_point = [0, 0, distance]
        cp_vector = np.array(cardinal_point)
        cp_vector_magnitude = np.linalg.norm(cp_vector)
        norm_cp_vector = cp_vector / cp_vector_magnitude

        # empty list for points
        poi_vectors: list = []

        # set iteration limits
        limit_x = self.__steps_x // 2
        limit_y = self.__steps_y // 2

        # create a rectangular plane of steps_x x steps_y points
        # the space between points is determined by the distance of the plane to the CCS origin.
        for m in range(-limit_x, limit_x + 1, 1):

            # get the angular offset xi and its rotation matrix
            xi = m * math.radians(ANGLE_INCREMENT)
            Rx = Rotation.from_euler("x", xi)

            for n in range(-limit_y, limit_y + 1, 1):

                # get the angular offset upsilon and its rotation matrix
                upsilon = n * math.radians(ANGLE_INCREMENT)
                Ry = Rotation.from_euler("y", upsilon)

                # full rotation matrix ordered xy
                Rxy = Rx * Ry

                # calculate the length of the current position vector P
                poi_vector_magnitude = cp_vector_magnitude / (
                    math.cos(xi) * math.cos(upsilon)
                )

                # calculate the current position vector P
                poi_vector = Rxy.apply(norm_cp_vector) * poi_vector_magnitude
                # ? get the offset vector S by setting the z components to 0

                poi_vectors.append(poi_vector)

        # reverse the vector list to rotate the plane by 180 degrees
        # the first point in the list is the top left corner of the plane
        poi_vectors.reverse()

        self.__plane_points = np.array(poi_vectors)

    def points(self) -> np.ndarray:
        """
            Getter method of the point list of the plane model.

        Returns:
            np.ndarray: Array containing the points of the plane model.
        """
        return self.__plane_points

    def size(self, in_pixel: bool = True):
        """
            Getter method of the plane size. Its output may be in pixels or in the unit of measurement selected at instance creation.

        Args:
            in_pixel (bool, optional): Boolean to select pixel as unit of measurement. Defaults to True.

        Returns:
            tuple[np.uint16, np.uint16]: The plane size in pixels.
            or
            tuple[np.float32, np.float32]: The actual plane size.
        """

        if in_pixel:
            return (self.__steps_x, self.__steps_y)
        else:
            return (self.__plane_width, self.__plane_height)

    def roi(self, original_cp: tuple[int, int], border: np.uint8 = 0) -> np.ndarray:
        """
            Calculates the region of interest according to the plane model in pixel coordinates.

        Args:
            original_cp (tuple[int, int]): The principal point coordinates of the original image.

        Returns:
            np.ndarray: The top left and bottom right vertices of the rectangular ROI arranged like [[x0 x1] [y0 y1]].
        """

        # image principal point
        cx, cy = original_cp

        # determin slices to cut the roi from images
        x0 = cx - self.__steps_y // 2 - border
        y0 = cy - self.__steps_x // 2 - border
        x1 = cx + self.__steps_y // 2 + 1 + border
        y1 = cy + self.__steps_x // 2 + 1 + border

        roi = np.array([[x0, x1], [y0, y1]], dtype=np.uint16)

        return roi
